AWSTemplateFormatVersion: '2010-09-09'
Resources:
  PatchInstanceWithRollbackKeepSnapshot:
    Type: 'AWS::SSM::Document'
    Properties:
      Name: 'PatchInstanceWithRollbackKeepSnapshot1'
      DocumentType: 'Automation'
      Content:
        schemaVersion: '0.3'
        description: Brings EC2 Instance into compliance with standing Baseline; rolls back root Volume on failure.
        assumeRole: '{{AutomationAssumeRole}}'
        parameters:
          InstanceId:
            type: String
            description: (Required) EC2 InstanceId to which we apply the patch-baseline
          ReportS3Bucket:
            type: String
            description: (Optional) S3 Bucket destination for the full Compliance Report generated during process
            default: ''
          AutomationAssumeRole:
            type: String
            description: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.
            default: ''
          LambdaAssumeRole:
            type: String
            description: (Optional) The ARN of the role that allows Lambda created by Automation to perform the actions on your behalf. If not specified a transient role will be created to execute the Lambda function.
            default: ''
          TopicArn:
            type: String
            description: '(Required) SNS Topic for Notifications. Example: arn:aws:sns:region:account-id:topic-name'
        mainSteps:
          - name: GetInstanceStatus
            action: aws:executeAwsApi
            nextStep: CheckInstanceStatus
            isEnd: false
            onFailure: Abort
            inputs:
              Service: ec2
              Api: DescribeInstanceStatus
              InstanceIds:
                - '{{InstanceId}}'
            outputs:
              - Name: InstanceState
                Selector: $.InstanceStatuses[0].InstanceState.Name
                Type: String
          - name: CheckInstanceStatus
            action: aws:branch
            inputs:
              Choices:
                - NextStep: ReportMessage_StartPatching
                  Variable: '{{GetInstanceStatus.InstanceState}}'
                  StringEquals: running
              Default: FailureMessage_CheckInstanceStatus
          - name: ReportMessage_StartPatching
            action: aws:executeAwsApi
            nextStep: createDocumentStack
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - 🟢 Start Patching'
              Service: sns
              TopicArn: arn:aws:sns:us-east-1:007695491693:Max
              Api: Publish
          - name: createDocumentStack
            action: aws:createStack
            maxAttempts: 8
            nextStep: IdentifyRootVolume
            isEnd: false
            onFailure: step:FailureMessage_createDocumentStack
            inputs:
              Capabilities:
                - CAPABILITY_IAM
              ClientRequestToken: '{{automation:EXECUTION_ID}}'
              StackName: PatchInstanceWithRollbackStack{{automation:EXECUTION_ID}}
              Parameters:
                - ParameterKey: LambdaRoleArn
                  ParameterValue: '{{LambdaAssumeRole}}'
                - ParameterKey: IdentifyRootVolumeLambdaName
                  ParameterValue: IdentifyRootVolumeLambda-{{automation:EXECUTION_ID}}
                - ParameterKey: SleepThruInstallationLambdaName
                  ParameterValue: SleepThruInstallationLambda-{{automation:EXECUTION_ID}}
                - ParameterKey: CheckComplianceLambdaName
                  ParameterValue: CheckComplianceLambda-{{automation:EXECUTION_ID}}
                - ParameterKey: SaveComplianceReportToS3LambdaName
                  ParameterValue: SaveRptToS3Lambda-{{automation:EXECUTION_ID}}
                - ParameterKey: ReportFailureLambdaName
                  ParameterValue: ReportFailureLambda-{{automation:EXECUTION_ID}}
                - ParameterKey: RestoreFromSnapshotLambdaName
                  ParameterValue: RestoreFromSnapshotLambda-{{automation:EXECUTION_ID}}
                - ParameterKey: DeleteSnapshotLambdaName
                  ParameterValue: DeleteSnapshotLambda-{{automation:EXECUTION_ID}}
              TemplateBody: |
                AWSTemplateFormatVersion: '2010-09-09'
                Conditions:
                  LambdaAssumeRoleNotSpecified:
                    Fn::Or:
                    - Fn::Equals:
                      - {Ref: LambdaRoleArn}
                      - ''
                    - Fn::Equals:
                      - {Ref: LambdaRoleArn}
                      - undefined
                Parameters:
                  CheckComplianceLambdaName: {Description: 'The lambda function name for the predicate
                      which evaluates the state of the EC-2 operand''s patch state compliance

                      ', Type: String}
                  DeleteSnapshotLambdaName: {Description: 'The lambda function name for the closings
                      cleanup predicate (case in which the EC-2 operand is deemed Compliant)

                      ', Type: String}
                  IdentifyRootVolumeLambdaName: {Description: 'The lambda function name for the predicate
                      which acquires the id of the root Volume of the operand EC2 Instance.

                      ', Type: String}
                  LambdaRoleArn: {Default: '', Description: 'The ARN of the role that allows Lambda
                      created by Automation to perform the action on your behalf

                      ', Type: String}
                  ReportFailureLambdaName: {Description: 'The lambda function name for the predicate
                      which reports failure upon detection execution failure state indicators

                      ', Type: String}
                  RestoreFromSnapshotLambdaName: {Description: 'The lambda function name for the recovery
                      action predicate (case in which the EC-2 operand is deemed NonCompliant)

                      ', Type: String}
                  SaveComplianceReportToS3LambdaName: {Description: 'The lambda function name for
                      the predicate which consumes a serialized Compliance report and saves it in
                      S3

                      ', Type: String}
                  SleepThruInstallationLambdaName: {Description: 'The lambda function name for the
                      predicate which monitors the installation, deferring subsequent step procession
                      until the installations are completed or the Lambda exhausts its allotted lifespan

                      ', Type: String}
                Resources:
                  CheckComplianceLambda:
                    Properties:
                      Code: {ZipFile: "import boto3\nfrom botocore.config import Config\nimport json\n\
                          import sys\nfrom datetime import datetime\n\nMAX_REPORT_ITEMS = 1200\nSUCCESS_MESSAGE\
                          \ = \"Instance patched successfully\"\nFAILURE_MESSAGE = \"Patching failed\
                          \ and Instance restored to original state\"\nLIMITED_REPORT_DESCRIPTION_MESSAGE\
                          \ = \"Listing last %d applicable compliance items. To get the full report\
                          \ use the option to persist report in S3\" % MAX_REPORT_ITEMS\nFULL_REPORT_DESCRIPTION_MESSAGE\
                          \ = \"Listing all compliance items.\"\nconfig = Config(\n\tretries = {\n\
                          \t\t'max_attempts': 20,\n\t\t'mode': 'standard'\n\t}\n)\nssm = boto3.client('ssm',\
                          \ config=config)\ns3 = boto3.resource('s3')\n\ndef is_compliant(ec2_id):\n\
                          \treport = {\n\t\t\"is_compliant\": None,\n\t\t\"items\": [],\n\t}\n\tnoncompliance_found\
                          \ = False\n\ttoken = None\n\twhile 1:\n\t\tif token is None:\n\t\t\tlist_compliance_result\
                          \ = ssm.list_compliance_items(\n\t\t\t\tFilters=[{'Key': 'ComplianceType',\
                          \ 'Values': ['Patch']}],\n\t\t\t\tResourceIds=[ec2_id],\n\t\t\t\tResourceTypes=[\"\
                          ManagedInstance\"]\n\t\t\t)\n\n\t\telse:\n\t\t\tlist_compliance_result =\
                          \ ssm.list_compliance_items(\n\t\t\t\tFilters=[{'Key': 'ComplianceType',\
                          \ 'Values': ['Patch']}],\n\t\t\t\tResourceIds=[ec2_id],\n\t\t\t\tResourceTypes=[\"\
                          ManagedInstance\"],\n\t\t\t\tNextToken=token\n\t\t\t)\n\t\tcompliances =\
                          \ list_compliance_result[\"ComplianceItems\"]\n\n\t\tfor a_val in compliances:\n\
                          \t\t\tpatch_item = {\n\t\t\t\t\"PatchId\": a_val[\"Id\"],\n\t\t\t\t\"Severity\"\
                          : a_val[\"Severity\"],\n\t\t\t\t\"ComplianceType\": a_val[\"ComplianceType\"\
                          ],\n\t\t\t\t\"State\": a_val[\"Details\"][\"PatchState\"]\n\t\t\t}\n\t\t\
                          \treport[\"items\"].append(patch_item)\n\t\t\tif a_val[\"Status\"] != \"\
                          COMPLIANT\" and a_val[\"Details\"][\"PatchState\"] != \"NotApplicable\"\
                          :\n\t\t\t\tnoncompliance_found = True\n\t\tif \"NextToken\" in list_compliance_result:\n\
                          \t\t\ttoken = list_compliance_result[\"NextToken\"]\n\t\telse:\n\t\t\tbreak\n\
                          \n\t\tif token is None:\n\t\t\tbreak\n\n\treport[\"is_compliant\"] = noncompliance_found\
                          \ is False\n\treturn report\n\ndef is_success_case(ec2_id):\n\treturn is_compliant(ec2_id)\n\
                          \ndef get_account_id(lambdaArn):\n\taccount_id = lambdaArn.split(\":\")[4]\n\
                          \treturn account_id\n\ndef get_region(lambdaArn):\n\tregion = lambdaArn.split(\"\
                          :\")[3]\n\treturn region\n\ndef save_to_s3(event, context, compliance_report):\n\
                          \taccount_id = get_account_id(context.invoked_function_arn)\n\tregion =\
                          \ get_region(context.invoked_function_arn)\n\tdate = str(datetime.now().day)\n\
                          \tmonth = str(datetime.now().month)\n\tyear = str(datetime.now().year)\n\
                          \tfile_path = \"AWSLogs/\" + account_id + \"/SystemsManager/\" + region\
                          \ + \"/\" + year + \"/\" + month + \"/\" + date + \"/\" + event[\"ReportFileName\"\
                          ]\n\trpt_s3_obj = s3.Object(event[\"S3Bucket\"], file_path)\n\trpt_s3_obj.put(Body=json.dumps(compliance_report))\n\
                          \n\treturn file_path\n\ndef filter_not_applicable_items(compliance_report):\n\
                          \tapplicable_items = []\n\tfor item in compliance_report:\n\t\tif item[\"\
                          State\"] != \"NotApplicable\":\n\t\t\tapplicable_items.append(item)\n\t\
                          return applicable_items\n\ndef handler(event, context):\n\tcompliance_report\
                          \ = is_success_case(event[\"InstanceId\"])\n\toutput = {\n\t\t\"Result\"\
                          : SUCCESS_MESSAGE if compliance_report[\"is_compliant\"] else FAILURE_MESSAGE,\n\
                          \t\t\"PatchingSuccess\": compliance_report[\"is_compliant\"]\n\t}\n\n\t\
                          if len(event[\"S3Bucket\"]) > 0:\n\t\tfile_path = save_to_s3(event, context,\
                          \ compliance_report[\"items\"])\n\t\toutput[\"ReportFileName\"] = file_path\n\
                          \t\toutput[\"S3Bucket\"] = event[\"S3Bucket\"]\n\n\tif len(compliance_report[\"\
                          items\"]) > MAX_REPORT_ITEMS:\n\t\toutput[\"Description\"] = LIMITED_REPORT_DESCRIPTION_MESSAGE\n\
                          \t\tapplicable_items = filter_not_applicable_items(compliance_report[\"\
                          items\"])\n\t\toutput[\"items\"] = applicable_items[-MAX_REPORT_ITEMS:]\n\
                          \telse:\n\t\toutput[\"Description\"] = FULL_REPORT_DESCRIPTION_MESSAGE\n\
                          \t\toutput[\"items\"] = compliance_report[\"items\"]\n\treturn output\n"}
                      FunctionName: {Ref: CheckComplianceLambdaName}
                      Handler: index.handler
                      MemorySize: 128
                      Role:
                        Fn::If:
                        - LambdaAssumeRoleNotSpecified
                        - Fn::GetAtt: [LambdaRole, Arn]
                        - {Ref: LambdaRoleArn}
                      Runtime: python3.8
                      Timeout: 300
                    Type: AWS::Lambda::Function
                  DeleteSnapshotLambda:
                    Properties:
                      Code: {ZipFile: "import boto3\nimport time\nfrom botocore.exceptions import\
                          \ ClientError\n\nSNAPSHOT_NOT_FOUND_ERROR_CODE = \"InvalidSnapshot.NotFound\"\
                          \nPOLL_INTERVAL = 5\nPOLL_MAX_TRIES = 8\n\nssm = boto3.client('ssm')\nec2\
                          \ = boto3.client('ec2')\n\n\ndef check_for_deletion(snapshot_id):\n\ttry:\n\
                          \t\tec2.describe_snapshots(SnapshotIds=[snapshot_id])\n\texcept ClientError\
                          \ as api_client_error:\n\t\tif api_client_error.response[\"Error\"][\"Code\"\
                          ] == SNAPSHOT_NOT_FOUND_ERROR_CODE:\n\t\t\treturn True\n\t\telse:\n\t\t\t\
                          raise\n\n\ndef wait_for_deletion(snapshot_id, max_tries=POLL_MAX_TRIES,\
                          \ wait_time=POLL_INTERVAL):\n\ttotal_iterations = 0\n\twhile total_iterations\
                          \ < max_tries:\n\t\ttotal_iterations += 1\n\t\tif check_for_deletion(snapshot_id)\
                          \ is True:\n\t\t\treturn True\n\t\ttime.sleep(wait_time)\n\n\ndef delete_snapshot(snapshot_id):\n\
                          \tec2.delete_snapshot(SnapshotId=snapshot_id)\n\twait_for_deletion(snapshot_id)\n\
                          \n\ndef handler(event, context):\n\tsnap_id = event[\"PrePatchSnapshot\"\
                          ]\n\n\tdelete_snapshot(snap_id)\n\treturn {\"ResultCase\": \"Snapshot Deleted\"\
                          }\n"}
                      FunctionName: {Ref: DeleteSnapshotLambdaName}
                      Handler: index.handler
                      MemorySize: 128
                      Role:
                        Fn::If:
                        - LambdaAssumeRoleNotSpecified
                        - Fn::GetAtt: [LambdaRole, Arn]
                        - {Ref: LambdaRoleArn}
                      Runtime: python3.8
                      Timeout: 60
                    Type: AWS::Lambda::Function
                  IdentifyRootVolumeLambda:
                    Properties:
                      Code: {ZipFile: "import boto3\n\nec2_client = boto3.client('ec2')\n\ndef get_root_device_name(instance_id):\n\
                          \troot_device_name = ec2_client.describe_instance_attribute(\n\t\tAttribute='rootDeviceName',\
                          \ InstanceId=instance_id\n\t)[\"RootDeviceName\"][\"Value\"]\n\treturn root_device_name\n\
                          \ndef get_root_volume_id_of_ec2(instance_id):\n\troot_device_name = get_root_device_name(instance_id)\n\
                          \tvolume_id = ec2_client.describe_volumes(\n\t\tFilters=[{'Name': 'attachment.instance-id',\
                          \ 'Values': [instance_id]},\n\t\t\t\t {'Name': 'attachment.device', 'Values':\
                          \ [root_device_name]}]\n\t)[\"Volumes\"][0][\"VolumeId\"]\n\treturn volume_id\n\
                          \n\ndef handler(event, context):\n\tinstance_id = event[\"InstanceId\"]\n\
                          \treturn get_root_volume_id_of_ec2(instance_id)\n"}
                      FunctionName: {Ref: IdentifyRootVolumeLambdaName}
                      Handler: index.handler
                      MemorySize: 128
                      Role:
                        Fn::If:
                        - LambdaAssumeRoleNotSpecified
                        - Fn::GetAtt: [LambdaRole, Arn]
                        - {Ref: LambdaRoleArn}
                      Runtime: python3.8
                      Timeout: 128
                    Type: AWS::Lambda::Function
                  LambdaRole:
                    Condition: LambdaAssumeRoleNotSpecified
                    Properties:
                      AssumeRolePolicyDocument:
                        Statement:
                        - Action: ['sts:AssumeRole']
                          Effect: Allow
                          Principal:
                            Service: [lambda.amazonaws.com]
                        Version: '2012-10-17'
                      Path: /
                      Policies:
                      - PolicyDocument:
                          Statement:
                            Action: ['ec2:CreateSnapshot', 'ec2:DeleteSnapshot', 'ec2:DescribeInstances',
                              'ec2:DescribeSnapshots', 'ec2:DescribeVolumes', 'ec2:DescribeInstanceAttribute',
                              'ec2:CreateVolume', 'ec2:AttachVolume', 'ec2:DetachVolume', 'ec2:StartInstances',
                              'ec2:StopInstances', 'ssm:ListCommands', 'ssm:ListComplianceItems',
                              's3:PutObject', 's3:PutObjectAcl', 'cloudwatch:*', 'logs:CreateLogGroup',
                              'logs:CreateLogStream', 'logs:PutLogEvents']
                            Effect: Allow
                            Resource: '*'
                          Version: '2012-10-17'
                        PolicyName: PatchInstanceWithRollbackLambdaPolicy
                    Type: AWS::IAM::Role
                  ReportFailureLambda:
                    Properties:
                      Code: {ZipFile: "\n\ndef handler(event, context):\n\tcompliance_report = event[\"\
                          CheckCompliance\"]\n\tif compliance_report[\"PatchingSuccess\"]:\n\t\treturn\
                          \ \"Patching Succeeded!\"\n\telse:\n\t\traise Exception(\"Patching Failed\"\
                          )\n"}
                      FunctionName: {Ref: ReportFailureLambdaName}
                      Handler: index.handler
                      MemorySize: 128
                      Role:
                        Fn::If:
                        - LambdaAssumeRoleNotSpecified
                        - Fn::GetAtt: [LambdaRole, Arn]
                        - {Ref: LambdaRoleArn}
                      Runtime: python3.8
                      Timeout: 60
                    Type: AWS::Lambda::Function
                  RestoreFromSnapshotLambda:
                    Properties:
                      Code: {ZipFile: "import boto3\nimport time\n\nssm = boto3.client('ssm')\nec2_client\
                          \ = boto3.client('ec2')\nec2_rsc = boto3.resource('ec2')\n\n\ndef count_vols_attached_to_host(vol):\n\
                          \treturn len(ec2_client.describe_volumes(VolumeIds=[vol.id])[\"Volumes\"\
                          ][0][\"Attachments\"])\n\n\ndef wait_4_detach(vol):\n\twhile count_vols_attached_to_host(vol)\
                          \ > 0:\n\t\ttime.sleep(5)\n\t\tif count_vols_attached_to_host(vol) == 0:\n\
                          \t\t\treturn True\n\n\ndef wait_4_attach(vol):\n\twhile count_vols_attached_to_host(vol)\
                          \ < 1:\n\t\ttime.sleep(5)\n\t\tif count_vols_attached_to_host(vol) == 1:\n\
                          \t\t\treturn True\n\n\ndef get_root_device_name(instance_id):\n\troot_device_name\
                          \ = ec2_client.describe_instance_attribute(\n\t\tAttribute='rootDeviceName',\
                          \ InstanceId=instance_id\n\t)[\"RootDeviceName\"][\"Value\"]\n\treturn root_device_name\n\
                          \n\ndef get_volume_id(instance_id, device_name):\n\tvolume_id = ec2_client.describe_volumes(\n\
                          \t\tFilters=[{'Name': 'attachment.instance-id', 'Values': [instance_id]},\n\
                          \t\t\t\t {'Name': 'attachment.device', 'Values': [device_name]}]\n\t)[\"\
                          Volumes\"][0][\"VolumeId\"]\n\treturn volume_id\n\n\ndef restore_vol_fm_snapshot(ec2_id,\
                          \ snap_id, dev, vol_id):\n\tvol = ec2_rsc.Volume(vol_id)\n\n\tnew_vol_init\
                          \ = ec2_client.create_volume(AvailabilityZone=vol.availability_zone, SnapshotId=snap_id)\n\
                          \tnew_vol_id = new_vol_init['VolumeId']\n\tnew_vol = ec2_rsc.Volume(new_vol_id)\n\
                          \tec2_client.get_waiter('volume_available').wait(VolumeIds=[new_vol_id])\n\
                          \n\tec2_client.stop_instances(InstanceIds=[ec2_id])\n\tec2_client.get_waiter('instance_stopped').wait(InstanceIds=[ec2_id])\n\
                          \n\tec2_client.detach_volume(Device=dev, InstanceId=ec2_id, VolumeId=vol_id)\n\
                          \twait_4_detach(vol)\n\tec2_client.attach_volume(Device=dev, InstanceId=ec2_id,\
                          \ VolumeId=new_vol_id)\n\twait_4_attach(new_vol)\n\n\tec2_client.start_instances(InstanceIds=[ec2_id])\n\
                          \tec2_client.get_waiter('instance_running').wait(InstanceIds=[ec2_id])\n\
                          \n\treturn True\n\n\ndef handler(event, context):\n\tinstance_id = event[\"\
                          InstanceId\"]\n\tsnap_id = event[\"SnapshotId\"]\n\troot_device_name = get_root_device_name(instance_id)\n\
                          \troot_volume_id = get_volume_id(instance_id, root_device_name)\n\n\trestore_vol_fm_snapshot(instance_id,\
                          \ snap_id, root_device_name, root_volume_id)\n\treturn {\"ResultCase\":\
                          \ \"Restoration Applied\"}"}
                      FunctionName: {Ref: RestoreFromSnapshotLambdaName}
                      Handler: index.handler
                      MemorySize: 128
                      Role:
                        Fn::If:
                        - LambdaAssumeRoleNotSpecified
                        - Fn::GetAtt: [LambdaRole, Arn]
                        - {Ref: LambdaRoleArn}
                      Runtime: python3.8
                      Timeout: 300
                    Type: AWS::Lambda::Function
                  SaveComplianceReportToS3Lambda:
                    Properties:
                      Code: {ZipFile: "\ndef handler(event, context):\n\tif (len(event[\"S3Bucket\"\
                          ]) > 0):\n\t\treturn {\n\t\t\t\"ReportFileName\": event[\"CheckCompliance\"\
                          ][\"ReportFileName\"],\n\t\t\t\"S3Bucket\": event[\"S3Bucket\"]\n\t\t}\n\
                          \telse:\n\t\treturn None\n"}
                      FunctionName: {Ref: SaveComplianceReportToS3LambdaName}
                      Handler: index.handler
                      MemorySize: 128
                      Role:
                        Fn::If:
                        - LambdaAssumeRoleNotSpecified
                        - Fn::GetAtt: [LambdaRole, Arn]
                        - {Ref: LambdaRoleArn}
                      Runtime: python3.8
                      Timeout: 60
                    Type: AWS::Lambda::Function
                  SleepThruInstallationLambda:
                    Properties:
                      Code: {ZipFile: "import boto3\n\nec2_rsc = boto3.resource('ec2')\n\n\ndef wait_for_restart(ec2_inst):\n\
                          \tec2_inst.wait_until_running()\n\n\ndef handler(event, context):\n\tinstance\
                          \ = ec2_rsc.Instance(event[\"InstanceId\"])\n\treturn wait_for_restart(instance)\n"}
                      FunctionName: {Ref: SleepThruInstallationLambdaName}
                      Handler: index.handler
                      MemorySize: 128
                      Role:
                        Fn::If:
                        - LambdaAssumeRoleNotSpecified
                        - Fn::GetAtt: [LambdaRole, Arn]
                        - {Ref: LambdaRoleArn}
                      Runtime: python3.8
                      Timeout: 300
                    Type: AWS::Lambda::Function
          - name: FailureMessage_createDocumentStack
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Oops, there was a failure with CreateDocumentStack!'
              TopicArn: '{{ TopicArn }}'
              Service: sns
              Api: Publish
          - name: IdentifyRootVolume
            action: aws:invokeLambdaFunction
            nextStep: PrePatchSnapshot
            isEnd: false
            onFailure: step:FailureMessage_IdentifyRootVolume
            inputs:
              FunctionName: IdentifyRootVolumeLambda-{{automation:EXECUTION_ID}}
              Payload: '{"InstanceId": "{{InstanceId}}"}'
          - name: FailureMessage_IdentifyRootVolume
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Oops, there was a failure with IdentifyRootVolume'
              Service: sns
              TopicArn: '{{ TopicArn }}'
              Api: Publish
          - name: FailureMessage_PrePatchSnapshot
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Oops, there was a failure with PrePatchSnapshot'
              Service: sns
              TopicArn: '{{ TopicArn }}'
              Api: Publish
          - name: PrePatchSnapshot
            action: aws:executeAutomation
            nextStep: CreateTagsForSnapShot
            isEnd: false
            onFailure: step:FailureMessage_PrePatchSnapshot
            inputs:
              DocumentName: AWS-CreateSnapshot
              RuntimeParameters:
                VolumeId: '{{IdentifyRootVolume.Payload}}'
                Description: ApplyPatchBaseline restoration case contingency
          - name: CreateTagsForSnapShot
            action: aws:executeAwsApi
            nextStep: installMissingUpdates
            isEnd: false
            onFailure: step:FailureMessage_CreateTagsForSnapShot
            inputs:
              Service: ec2
              Api: CreateTags
              Tags:
                - Key: Name
                  Value: Patching
                - Key: Patching
                  Value: DeleteDeny
              Resources: '{{ PrePatchSnapshot.Output }}'
          - name: FailureMessage_CreateTagsForSnapShot
            action: aws:executeAwsApi
            nextStep: DeleteSnapshot
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Oops, there was a failure with CreateTagsForSnapShot'
              TopicArn: '{{ TopicArn }}'
              Service: sns
              Api: Publish
          - name: DeleteSnapshot
            action: aws:executeAwsApi
            nextStep: FailureMessage_DeleteSnapshotdSuccess
            isEnd: false
            onFailure: step:FailureMessage_DeleteSnapshot
            inputs:
              Service: ec2
              Api: DeleteSnapshot
              SnapshotId: '''{{ PrePatchSnapshot.Output }}'''
          - name: FailureMessage_DeleteSnapshotdSuccess
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Patching failed. Snapshot was successfully deleted..'
              TopicArn: '{{ TopicArn }}'
              Service: sns
              Api: Publish
          - name: FailureMessage_DeleteSnapshot
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Oops, there was a failure with DeleteSnapshot'
              TopicArn: '{{ TopicArn }}'
              Service: sns
              Api: Publish
          - name: installMissingUpdates
            action: aws:runCommand
            maxAttempts: 1
            nextStep: SleepThruInstallation
            isEnd: false
            onFailure: step:FailureMessage_installMissingUpdates
            inputs:
              DocumentName: AWS-RunPatchBaseline
              InstanceIds:
                - '{{InstanceId}}'
              Parameters:
                Operation: Install
          - name: FailureMessage_installMissingUpdates
            action: aws:executeAwsApi
            nextStep: SleepThruInstallation
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Oops, there was a failure with installMissingUpdates'
              TopicArn: '{{ TopicArn }}'
              Service: sns
              Api: Publish
          - name: SleepThruInstallation
            action: aws:invokeLambdaFunction
            maxAttempts: 10
            nextStep: CheckCompliance
            isEnd: false
            inputs:
              FunctionName: SleepThruInstallationLambda-{{automation:EXECUTION_ID}}
              Payload: '{"InstanceId": "{{InstanceId}}"}'
          - description: Check compliance status of instance and output report of compliance items. Output may not contain all items, the full report will be in S3 if S3Bucket is specified.
            name: CheckCompliance
            action: aws:invokeLambdaFunction
            nextStep: SaveComplianceReportToS3
            isEnd: false
            onFailure: step:FailureMessage_CheckCompliance
            inputs:
              FunctionName: CheckComplianceLambda-{{automation:EXECUTION_ID}}
              Payload: '{"InstanceId": "{{InstanceId}}", "S3Bucket": "{{ReportS3Bucket}}", "ReportFileName": "PatchInstanceWithRollback-{{automation:EXECUTION_ID}}.json"}'
          - name: FailureMessage_CheckCompliance
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Oops, there was a failure with CheckCompliance'
              TopicArn: '{{ TopicArn }}'
              Service: sns
              Api: Publish
          - name: SaveComplianceReportToS3
            action: aws:invokeLambdaFunction
            nextStep: ReportSuccessOrFailure
            isEnd: false
            onFailure: step:FailureMessage_SaveComplianceReportToS3
            inputs:
              FunctionName: SaveRptToS3Lambda-{{automation:EXECUTION_ID}}
              Payload: '{"S3Bucket": "{{ReportS3Bucket}}", "CheckCompliance": {{CheckCompliance.Payload}}}'
          - name: FailureMessage_SaveComplianceReportToS3
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Oops, there was a failure with SaveComplianceReportToS3'
              TopicArn: '{{ TopicArn }}'
              Service: sns
              Api: Publish
          - name: ReportSuccessOrFailure
            action: aws:invokeLambdaFunction
            maxAttempts: 1
            nextStep: UpdateTagsForSnapShot
            isEnd: false
            onFailure: step:FailureMessage_ReportSuccessOrFailure
            inputs:
              FunctionName: ReportFailureLambda-{{automation:EXECUTION_ID}}
              Payload: '{"CheckCompliance": {{CheckCompliance.Payload}}}'
          - name: UpdateTagsForSnapShot
            action: aws:executeAwsApi
            nextStep: SuccessReportMessage
            isEnd: false
            onFailure: step:FailureMessage_UpdateTagsForSnapShot
            inputs:
              Service: ec2
              Api: CreateTags
              Resources: '{{ PrePatchSnapshot.Output }}'
              Tags:
                - Key: Patching
                  Value: DeleteAllow
          - name: FailureMessage_UpdateTagsForSnapShot
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Oops, there was a failure with UpdateTagsForSnapShot'
              TopicArn: '{{ TopicArn }}'
              Service: sns
              Api: Publish
          - name: FailureMessage_ReportSuccessOrFailure
            action: aws:executeAwsApi
            nextStep: RestoreFromSnapshot
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Oops, there was a failure with ReportSuccessOrFailure'
              TopicArn: '{{ TopicArn }}'
              Service: sns
              Api: Publish
          - name: RestoreFromSnapshot
            action: aws:invokeLambdaFunction
            nextStep: SuccessRestoreMessage_RestoreFromSnapshot
            isEnd: false
            onFailure: step:FailureMessage_RestoreFromSnapshot
            inputs:
              FunctionName: RestoreFromSnapshotLambda-{{automation:EXECUTION_ID}}
              Payload: '{"InstanceId": "{{InstanceId}}", "SnapshotId": "{{PrePatchSnapshot.Output}}", "CheckCompliance": {{CheckCompliance.Payload}}}'
          - name: FailureMessage_RestoreFromSnapshot
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Oops, there was a failure with RestoreFromSnapshot'
              TopicArn: '{{ TopicArn }}'
              Service: sns
              Api: Publish
          - name: SuccessRestoreMessage_RestoreFromSnapshot
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Patching failed. Rostore from snapshot was successful.'
              Service: sns
              TopicArn: '{{ TopicArn }}'
              Api: Publish
          - name: FailureMessage_CheckInstanceStatus
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ⚠️ Patching has been skipped. Instance Status is not running.'
              Service: sns
              TopicArn: '{{ TopicArn }}'
              Api: Publish
          - name: deleteCloudFormationTemplate
            action: aws:deleteStack
            maxAttempts: 16
            isEnd: true
            inputs:
              StackName: PatchInstanceWithRollbackStack{{automation:EXECUTION_ID}}
          - name: SuccessReportMessage
            action: aws:executeAwsApi
            nextStep: deleteCloudFormationTemplate
            isEnd: false
            inputs:
              Message: '{{ global:ACCOUNT_ID }}-{{ global:REGION }}-{{ InstanceId }} - ✅ Patching has been successfully installed.'
              Service: sns
              TopicArn: '{{ TopicArn }}'
              Api: Publish
        outputs:
          - IdentifyRootVolume.Payload
          - PrePatchSnapshot.Output
          - SaveComplianceReportToS3.Payload
          - RestoreFromSnapshot.Payload
          - CheckCompliance.Payload
